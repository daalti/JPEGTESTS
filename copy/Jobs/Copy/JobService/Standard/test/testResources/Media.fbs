include "APIResult.fbs";
include "MediaType.fbs";
include "MediaSizeId.fbs";
include "MediaSize.fbs";
include "MediaDestinationId.fbs";
include "MediaSource.fbs";
include "MediaId.fbs";
include "Distance.fbs";
include "Margins.fbs";
include "Plex.fbs";

namespace dune.print.engine;


// TODO: Port here all enumerations that need to be in a fbs

/**
 *  General Media device types
 */
enum MediaDeviceType:uint
{
	INPUT,
	OUTPUT,
	MEDIAPATH,
	FINISHER
}

 /**
  * Order to obtain the device list as it may be useful for some clients
  */
enum DeviceOrder: uint
{
    DONT_CARE, //< Client does not care about the order of the devices
    FORWARD,   //< Client wants to obtain from first (top) to last (bottom) device
    REVERSE,   //< Client wants to obtain from last (bottom) to first (top) device
    PRIORITY   //< Client wants to obtain from more priority to less priority to print
}


/**
  * The operation types supported
  */
enum MediaOperation: uint
{
    LOAD,                 // Ask for a media load (or attach paper in an output roll)
    UNLOAD,               // Ask for unloading the media (or detach paper in an output roll)
    JAM_REMOVAL,          // Ask for resolve a Jam
    MOVE,                 // Ask for moving the media
    CUT,                  // Perform the form-feed and cut
    REPLACE,              // Replace the device
    CALIBRATE,            // Calibrate the device
    ATTACH,               // Attach take up reel 
    DETACH,               // Detach take up reel
    WARMUP,               // Request media warmup
    CLEAN,                // Clean the device/Media
    DEACTIVATE_SMART_TUR, // Permorm deactivate smart take up reel to be freely manipulated
    RELEASE,              // Lift pinches up to release paper
    INSTALL,              // Install the device
    UNINSTALL,            // Uninstall the device
    CLEAR_FULL,           // Clear full in the device
    CLOSE_COVER           // Close cover of the device
}

/**
  * The Input Device types supported
  */
enum InputType: uint
{
    TRAY,
    ROLL
}

/**
  * The Output Device types supported
  */
enum OutputType: uint
{
    BIN,
    ROLL
}

/**
  * MediaPath Devices supported
  */
enum MediaPathType: uint
{
    FLIPPER,
    PRINTZONE,
    DUPLEXER,
    INK_COLLECTOR,
    HEATER,
    CURING
}

/**
  * The Finisher Devices supported
  */
enum FinisherType: uint
{
    CUTTER,
    STAPLER,
    FOLDER,
    LFP_FOLDER,
    LFP_TAKE_UP_REEL,
    STACKER,
    PAGEBASED_FINISHER
    // TODO
}

/**
￼      * The installation type of the device
￼      */
enum InstallationType: uint
{
    BUILTIN,             // Part of the printer
    USER_INSTALLABLE,    // User can install the device
    SERVICE_INSTALLABLE  // Only service engineer can install the device
}

enum TrayFeedType: uint
{
    AUTOMATIC,           // Printer is able to feed itself from this tray
    MANUAL,               // User still needs to manually feed the printer from this tray
    MULTI_PURPOSE        // Similar to manual , but the tray can be feed a small stack of sheets that it can automatically pick
}

/**
  * Device State (Input, Output, Finisher or MediaPath)
  *
  * @note A device can only be used to print when the status is OK.
  *       If the deivice is at INFORM device might be Busy and client can query getDeviceStatus() for more information.
  *       If the deivice is at ERROR/WARNING it requires user intervention and client can query getDeviceStatus() for more information.
  */
enum DeviceState: uint
{
    OK,      // Device ready for printing and there is no DeviceStatus with detailed information
    INFORM,  // Device is ready for printing, but it provide some DeviceStatus with detailed information
    ERROR,   // Device is NOT readyfor printing (Blocked by an error condition, check DeviceStatus for detailed information)
    WARNING, // Device is ready for printing but may fail in soon-future if warning condition not fixed (chec DeviceStatus for detailed information)
}

/**
￼      * Device Status (Input, Output, Finisher or MediaPath)
￼      * note: Based on Device State
￼      */
enum DeviceStatus: uint
{
    //Device State is OK
    READY,

    //Device State is INFORM
    DOOR_OPEN,       // Tray Door is Open
    SIDE_DOOR_OPEN,  // Tray Side Door is Open
    UPGRADING,       // Device performing a firmware upgrade - Device cannot be used
    INITIALIZING,    // Busy performing initialization - Device cannot be used
    CHECKING,        // Busy performing a load, self-check operation, being open, etc - Device cannot be used until ready
    PRINTING,        // Busy in a print operation - Device can be used for next page
    INSTALLED,       // Optioal device installed on the printer
    DETACHED,        // The device has not attached media (make sense on ROLL devices when media is not attached. Eg TakeUpReel that requires attach the media)
    DISABLED,        // Device disabled
    OPEN,            // Device open (e.g. stacker)
    CONFIGURATION_CHANGED, // Tray media configurations are changed
    OCCUPIED, //Set when Tray is loaded with paper
    // TODO: Not clear statuses (to be reviewed)
    STANDBY,          // Media in standby position
    LIFTING,          // Tray lifing for loading paper


    //Device State is ERROR
    GENERIC,                // Unspecified error
    OUT_OF_MEDIA,           // No media in an input
    JAM,                    // A Jam ocurred
    BLOCKED,                // Another Device Status prevents this one to be used
    INCORRECTLY_LOADED,     // Not properly loaded
    INVALID_SIZE_TOO_LONG,  // Loaded Media size configured by user is not supported or inconsistent with the detected (configured media too big)
    INVALID_SIZE_TOO_SHORT, // Loaded Media size configured by user is not supported or inconsistent with the detected (configured media too small)
    HARDWARE_ERROR,         // Determined that the input is not working properly, most likely due to a hardware problem
    COMM_ERROR,             // Communication Error
    NOT_INITIALIZED,        // Not initialized, it may require user intervention to initialize it ( OR DISABLED? )
    CABLE_DISCONNECTED,     // Device cable disconnected
    LIFTING_ERROR,

    // TODO: Not clear statuses (to be reviewed)
    REQUIRES_CALIBRATION,   // The deive needs to be calbrated to be used (error or warning?)
    BAD_MEDIA_MOVEMENTS,    // Detected that the media does not move properly (error or warning?)
    NOT_INSTALLED,          // The device is not installed properly and requres user intervetion to install it
    MEDIA_LENGTH_CONSUMED,   // Specified length consumes

    //Device State is WARNING
    MEDIA_SENSITIVE,        // The media properties are not adequate for the printing process
    MEDIA_UNCUTTABLE,       // The media will be printed but cannot be cut
    MEDIA_PROTECTED,        // Warns that this device won't be used when printing on the "default" route
    ALMOST_OUT_OF_MEDIA,    // Warns about low media present on device
    BAD_LENGTH_PLOTS,       // It will print, but result is not guaranteed to be visually correct
    MEDIA_OVERFILL,         // Media overfill in the input device, output is full
    SIZE_ERROR,
    MISPRINT,
    LOCKED,
    PICKUP_REQUIRED,   //Pickup Required in the OutputBIn
    LOW_ON_MEDIA,       // Warns about low media present on device
    LIFTUP_INTERRUPTED
}

/**
 * The output bin operation mode
 */
enum BinOperationMode : uint
{
    NONE = 1,    
    MAILBOX, 
    STACKER,             // The bin stacks the printed pages
    FUNCTION_SEPARATOR,
    JOB_SEPARATOR,
    COLLATOR,
    BASKET,               // The bin is just a basket where the printed page falls into (no operation)
    MAILBOX_STACKER       // A part of the bin is assigned to a person or group of persons (treats as mailbox mode) and the rest of the bin is used as a stacker
}

/**
  * The Drawer Status supported
  */
enum DrawerStatus : uint
{
    NOT_INSTALLED, // The drawer is not installed
    INSTALLED,     // The drawer is installed, if 0 do not bother in looking at the rest of the fields or the roll status
    FAILURE,       // There is a HARDWARE error in the drawer that prevents the machine from using it.
    OPEN,          // The drawer is open (if this triggers a loading or not, it depends on the state of the machine)
    JAM_DOOR_OPEN, // The jam door of the drawer is detected as open, this should be only reported as an error if a proc or print state says so
    BUSY,          // The drawer is being used by the machine for some operation (this will be the same value as the one used to switch the white led on on the drawer)
    DETECTED       // The drawer has been detected by the system. it can be not installed if the system is not configured to have this drawer installed
}


enum TrayDiscreteLevel: uint
{
    FULL,            // The tray level is full ( discrete level indicating tray is full of media)
    MEDIUM,          // The tray level is medium ( discrete level indicating tray reached medium threshold of media)
    LOW,             // The tray level is low  ( discrete level indicating tray reached low threshold of media)
    VERY_LOW,        // The tray level is vey low ( discrete level indicating tray reached very low threshold of media)
    EMPTY,           // The tray has no media (empty)
    UNKNOWN          // The tray level is unknown
}

/**
  * Types of print zone
  */
enum PrintZoneType: uint
{
    PLATEN,
    INK_COLLECTOR
}

/**
  * Orientation that the sheet has once printed
  * ( put it in global fbs, now is replicated on MediaSimulatorConfig.fbs )
  *  For Input/Tray - Orientation that the sheet is placed in tray to be printed on the correct side
  *  For Output/Bin - Orientation that the sheet is delivered once printed
  */
enum PageOrientation: uint
{
    FACE_UP,
    FACE_DOWN,
    FACE_BOTH,
    FACE_UNKNOWN
}

/**
  * Finisher Folding device specifig data
  *
  */
enum OutputFace : uint
{
    UNKNOWN,
    FACE_UP,
    FACE_DOWN
}

enum StyleSefLef : uint
{
    BOTH,          // Both deliveries can be done.
    SEF,           // Short Edge First. Portrait.
    LEF,           // Long Edge First. Landscape.
    SIZE_DEPENDANT // Size dependant.
}

enum ConfigFoldingStyle : uint
{
    NOT_FOLD,       // Not folded
    USER,           // User defined style
    FOLDER_SELECTS  // Built-in folding style.
}

enum TitleBlockPosition: uint
{
    UNKNOWN,
    UP_LEFT,
    UP_RIGHT,
    BOTTOM_RIGHT,
    BOTTOM_LEFT
}

/**  ReferenceEdge attribute specifies which edge is used as the basis of the cut, perforation, or score.
  *  Cuts, perforations, and scores are placed parallel to the reference edge at the offset specified by the
  *  "trimming-offset" member attribute.
*/
enum ReferenceEdge: uint
{
    BOTTOM,       // Bottom edge
    LEFT,         // Left edge
    RIGHT,        // Right edge
    TOP           // Top Edge
}

/** TrimmingType attribute specifies the type of trim that is to be performed
  *
  */
enum TrimmingType: uint
{
    FULL,       // Cuts the hardcopy output the full length parallel to the reference edge
    PARTIAL,    // Partially cuts the hardcopy output along the length parallel to the reference edge
    PERFORATE,  // Perforates the hardcopy output the full length parallel to the reference edge
    SCORE,      // Scores the hardcopy output the full length parallel to the reference edge
    TAB,        // Cuts the hardcopy output along the length parallel to the reference edge leaving a hanging tab
    DRAW_LINE   // Marks a cut line on the media where it could be cut by an operator
}

/** TrimmingType attribute specified when trimming is performed
  *
  */
enum TrimmingWhen: uint
{
    AFTER_SHEETS,               // Trimming occurs after each sheet
    AFTER_SETS,                 // Trimming occurs after each Set (the typical default)
    AFTER_DOCUMENTS,            // Trimming occurs after each Document
    AFTER_JOB                   // Trimming occurs only after the entire Job is printed
}

enum DeviceSettingFieldType: uint32
{
    // enable or disable the LOP message being show up to user. Disabled by default.
    LOW_ON_PAPER_MESSAGE_ENABLE,

    // default input source selection
    DEFAULT_MEDIA_SOURCE,

    INVALID,

    // List last used paper sizes first. Disabled by default.
    LIST_LAST_USED_PAPER_SIZES_FIRST,

    // enable or disable size/type prompt. Enabled by default. Persistent setting stored in MediaHandlingSettings.
    SIZE_TYPE_PROMPT_ENABLE,

    // Tray Lock Settings. Each bit represents whether tray lock is enabled on their respective trays.
    TRAY_LOCK,

    // Setting to determine whether A4 and Letter paper size are allowed to be interchangeable.
    A4_LETTER_MISMATCH,

    // Setting to enable the print barcode functionatly when unloading a roll
    MEDIA_TRACKING_BARCODE
}


enum ConstraintsType: uint32
{
   NONE,               // There aren't any kind of constraints (i.e.: fully supported)
   MEDIA_ID,           // This Margins object is only constrained by MediaId
   MEDIA_SIZE,         // This Margins object is only constrained by MediaSize
   MEDIA_ID_AND_SIZE   // This Margins object is constrained by certain combinations of MediaId and MediaSize
}


// All the schemas for the SnapShots so the flatbuffer can be shared:
table DeviceSnapshotFbs
{
  snapStatus:[DeviceStatus];
  snapState:DeviceState;
}


table InputSnapshotFbs
{
  deviceSnapshot:DeviceSnapshotFbs;
  hasSnapMediaSize:bool;
  snapMediaSize:dune.imaging.types.MediaSizeFbs;
  hasSnapMediaId:bool;
  snapMediaId:dune.imaging.types.MediaIdFbs;
  hasSnapMediaLoadOrientation:bool;
  snapMediaLoadOrientation:dune.imaging.types.MediaOrientation=PORTRAIT;
}

table InputTraySnapshotFbs
{
  inputSnapshot:InputSnapshotFbs;
  hasSnapLevelPercentage:bool;
  snapLevelPercentage:uint;
  hasDiscreteLevel:bool;
  discreteLevel:TrayDiscreteLevel=EMPTY;
  hasMediaSizeSelectedForLocking:bool;
  mediaSizeSelectedForLocking:dune.imaging.types.MediaSizeFbs;
}

table InputRollSnapshotFbs
{
  inputSnapshot:InputSnapshotFbs;
  hasSnapLevelPercentage:bool;
  snapLevelPercentage:uint;
}


table DrawerSnapshotFbs
{
  snapDrawerStatus:[DrawerStatus];
}


table OutputSnapshotFbs
{
  deviceSnapshot:DeviceSnapshotFbs;
}

table OutputBinSnapshotFbs
{
  outputSnapshot:OutputSnapshotFbs;
  hasSnapRemainingSheets:bool;
  snapRemainingSheets:uint;
}

table FinisherSnapshotFbs
{
  deviceSnapshot:DeviceSnapshotFbs;
}

table CutterSnapshotFbs
{
  finisherSnapshot:FinisherSnapshotFbs;
  cutterEnabled:bool;
  manualCutEnabled:bool;
}

table FolderSnapshotFbs
{
  finisherSnapshot:FinisherSnapshotFbs;
}

table PageBasedFinisherSnapshotFbs
{
  finisherSnapshot:FinisherSnapshotFbs;
}

table LargeFormatFolderSnapshotFbs
{
  finisherSnapshot:FinisherSnapshotFbs;
}

table LargeFormatTakeUpReelSnapshotFbs
{
  finisherSnapshot:FinisherSnapshotFbs;
}

table MediaPathSnapshotFbs
{
  deviceSnapshot:DeviceSnapshotFbs;
}

table PrintZoneSnapshotFbs
{
  mediaPathSnapshot:MediaPathSnapshotFbs;
  snapPrintZoneType: PrintZoneType = PLATEN;
}

table DuplexerSnapshotFbs
{
  mediaPathSnapshot: MediaPathSnapshotFbs;
}

table FlipperSnapshotFbs
{
  mediaPathSnapshot: MediaPathSnapshotFbs;
}

table HeaterSnapshotFbs
{
  mediaPathSnapshot:MediaPathSnapshotFbs;
  hasCurrentTemperature : bool;
  currentTemperature : float;
  hasTargetTemperature : bool;
  targetTemperature : float;
}

table CuringSnapshotFbs
{
  mediaPathSnapshot:MediaPathSnapshotFbs;
  hasCuringState : bool; // Not used. Cannot remove due to fbs schema validator
  hasCurrentTemperature : bool;
  currentTemperature : float;
  hasTargetTemperature : bool;
  targetTemperature : float;
}

// FBS counterpart definitions of Media type classes ( not enums )

table MinAndMaxFbs{
    min: dune.imaging.types.DistanceFbs;
    max: dune.imaging.types.DistanceFbs;
}

// Device Snapshot FBS classes adjusted to the max to real IMedia classes counterparts hierarchy --------------------------------------------------------
//
// NOTE : At this moment used only in MediaSimulatorConfig.fbs
//

table MarginsParametersFbs
{
    fullBleed:bool;
    edgeToEdge:bool;
    mediaSize:dune.imaging.types.MediaSizeFbs;
    mediaId:dune.imaging.types.MediaIdFbs;
    plexMode:dune.imaging.types.Plex;
    plexSide:dune.imaging.types.PlexSide;
    desiredMargins:dune.imaging.types.MarginsFbs;
    mediaSource:dune.imaging.types.MediaSource;
}

table FullBleedCombinationFbs
{
    mediaId   : dune.imaging.types.MediaIdFbs;
    mediaSize : dune.imaging.types.MediaSizeFbs;
}

table FullBleedConstraintsFbs
{
  supportedIds   : [ dune.imaging.types.MediaIdFbs ];
  supportedSizes : [ dune.imaging.types.MediaSizeFbs ];
  supportedCombinations : [ FullBleedCombinationFbs ];
}

table MarginsCombinationFbs
{
  mediaId   : dune.imaging.types.MediaIdFbs;
  mediaSize : dune.imaging.types.MediaSizeFbs;
}

table MarginsConstraintsFbs
{
  constraintsType: dune.print.engine.ConstraintsType;
  margins        : dune.imaging.types.MarginsFbs;
  supportedIds   : [ dune.imaging.types.MediaIdFbs ];
  supportedSizes : [ dune.imaging.types.MediaSizeFbs ];
  supportedCombinations : [ MarginsCombinationFbs ];
}

union InputSnapshotType{
    InputTraySnapshotFbs,
    InputRollSnapshotFbs
}

union OutputSnapshotType{
    OutputBinSnapshotFbs
}

union MediaPathSnapshotType{
    PrintZoneSnapshotFbs,
    FlipperSnapshotFbs,
    DuplexerSnapshotFbs,
    HeaterSnapshotFbs,
    CuringSnapshotFbs
}

union FinisherSnapshotType
{
    CutterSnapshotFbs,
    LargeFormatFolderSnapshotFbs,
    LargeFormatTakeUpReelSnapshotFbs,
    FolderSnapshotFbs,
    PageBasedFinisherSnapshotFbs
}

union InputDeviceType
{
  InputTrayFbs,
  InputRollFbs
}

union MediaPathDeviceType
{
    PrintZoneFbs,
    FlipperFbs,
    DuplexerFbs,
    HeaterFbs,
    CuringFbs
}

union FinisherDeviceType
{
    CutterFbs,
    FolderFbs,
    LargeFormatFolderFbs,
    LargeFormatTakeUpReelFbs,
}


// ------------------------------------------------------------------------------------------------------------------------------------


// All the schemas to carry IMedia classes data
table DeviceFbs
{
  identifier:uint;
  hasInstallationType:dune.framework.core.fbs.APIResult;
  installationType:InstallationType;
  hasFirmwareVersion:dune.framework.core.fbs.APIResult;
  firmwareVersion:string;
  hasMediaSupportedSizes:dune.framework.core.fbs.APIResult;
  mediaSupportedSizes:[dune.imaging.types.OrientedMediaSizeFbs];
  hasSupportedMediaWidths:dune.framework.core.fbs.APIResult;
  supportedMediaWidths:MinAndMaxFbs;
  hasSupportedMediaLengths:dune.framework.core.fbs.APIResult;
  supportedMediaLengths:MinAndMaxFbs;
  hasIsCustomSizeSupported:dune.framework.core.fbs.APIResult;
  isCustomSizeSupported:bool;
  hasMediaSupportedTypes:dune.framework.core.fbs.APIResult;
  mediaSupportedTypes:[dune.imaging.types.MediaIdFbs];
  hasSupportedMediaOperations:dune.framework.core.fbs.APIResult;
  supportedMediaOperations:[MediaOperation];
  considerSupportedWidthsAndLengthsAsMediaSizes:bool;
  hasVendor:dune.framework.core.fbs.APIResult;
  vendor:string;
  hasModel:dune.framework.core.fbs.APIResult;
  model:string;
  hasSerialNumber:dune.framework.core.fbs.APIResult;
  serialNumber:string;
}

table InputTrayFbs
{
  device:DeviceFbs;
  hasSheetsCapacity:dune.framework.core.fbs.APIResult;
  sheetsCapacity:uint;
  hasTrayLowThreshold:dune.framework.core.fbs.APIResult;
  trayLowThreshold:uint;
  hasFeedOrientationSupported:dune.framework.core.fbs.APIResult;
  feedOrientationSupported:dune.imaging.types.MediaOrientation;
  hasPageFaceOrientation:dune.framework.core.fbs.APIResult;
  pageFaceOrientation:PageOrientation;
  hasIsTrayPartOfPaperPath:dune.framework.core.fbs.APIResult;
  isTrayPartOfPaperPath:bool;
  hasIsMediaSizeSensingSupported:dune.framework.core.fbs.APIResult;
  isMediaSizeSensingSupported:bool;
  hasIsMediaTypeSensingSupported:dune.framework.core.fbs.APIResult;
  isMediaTypeSensingSupported:bool;
  hasIsMediaElectronicLevelSensingSupported:dune.framework.core.fbs.APIResult;
  isMediaElectronicLevelSensingSupported:bool;
  hasIsMediaDiscreteLevelSensingSupported:dune.framework.core.fbs.APIResult;
  isMediaDiscreteLevelSensingSupported:bool;
  hasMediaDetectableSizes:dune.framework.core.fbs.APIResult;
  mediaDetectableSizes:[dune.imaging.types.OrientedMediaSizeFbs];
  hasMediaDetectableTypes:dune.framework.core.fbs.APIResult;
  mediaDetectableTypes:[dune.imaging.types.MediaIdFbs];
  hasInputTraySnapshot:dune.framework.core.fbs.APIResult;
  inputTraySnapShot:InputTraySnapshotFbs;
  hasFeedType:dune.framework.core.fbs.APIResult;
  feedType:TrayFeedType;
}

table DrawerFbs
{
  hasPosition:dune.framework.core.fbs.APIResult;
  position:uint32;
}

table InputRollFbs
{
  device:DeviceFbs;
  hasIsSwitchable:dune.framework.core.fbs.APIResult;
  isSwitchable:bool;
  hasDrawer:dune.framework.core.fbs.APIResult;
  drawer:DrawerFbs;
  hasInputRollSnapshot:dune.framework.core.fbs.APIResult;
  inputRollSnapShot:InputRollSnapshotFbs;
}

table InputFbs
{
  input:InputDeviceType;
  mediaSource:dune.imaging.types.MediaSource;
  hasPhysicalMargins:bool;
  physicalMargins:dune.imaging.types.MarginsFbs;
  hasFullBleedConstraints:bool;
  fullBleedConstraints:FullBleedConstraintsFbs;
  hasUserReportedMargins:bool;
  userReportedMargins: [dune.imaging.types.MarginsFbs];
  isAlternativeMediaSourcesSupported:bool;
  alternativeMediaSources:[dune.imaging.types.MediaSource];
  hasMarginsConstraints:bool;
  marginsConstraintsCollection:[MarginsConstraintsFbs];
}


table OutputBinFbs
{
  device:DeviceFbs;
  hasPageDeliveryOrientation:dune.framework.core.fbs.APIResult;
  pageDeliveryOrientation:PageOrientation;
  hasMediaDestinationId:dune.framework.core.fbs.APIResult;
  mediaDestinationId: dune.imaging.types.MediaDestinationId;
  hasSupportsManualMode:dune.framework.core.fbs.APIResult;
  supportsManualMode:bool;
  hasCapacityInSheets:dune.framework.core.fbs.APIResult;
  capacityInSheets:uint;
  hasIsBinFullSupported:dune.framework.core.fbs.APIResult;
  isBinFullSupported:bool;
  hasIsBinExternal:dune.framework.core.fbs.APIResult;
  isBinExternal:bool;
  hasIsBinPartOfPaperPath:dune.framework.core.fbs.APIResult;
  isBinPartOfPaperPath:bool;
  hasIsBinPartOfDuplexPath:dune.framework.core.fbs.APIResult;
  isBinPartOfDuplexPath:bool;
  hasIsBinPartOfFinishingPath:dune.framework.core.fbs.APIResult;
  isBinPartOfFinishingPath:bool;
  binOperationMode: BinOperationMode = NONE;
  outputBinSnapshot:OutputBinSnapshotFbs;
}

table TrimmingStyleFbs
{
  id: uint32;
  name: string;
  referenceEdge: ReferenceEdge;
  offsetInPu: uint32;
  whenPerform: TrimmingWhen;
  type: TrimmingType;
}

table CutterPropertiesFbs
{
  trimmingStyles: [TrimmingStyleFbs];
  defaultTrimmingStyleId: uint32;
  enableSupported : bool;
}

table CutterFbs
{
  device:DeviceFbs;
  hasCutterSnapshot:dune.framework.core.fbs.APIResult;
  cutterSnapshot:CutterSnapshotFbs;
  hasCutterProperties:dune.framework.core.fbs.APIResult;
  cutterProperties: CutterPropertiesFbs;
}

table FolderFbs
{
  device:DeviceFbs;
}

table LargeFormatFolderFbs
{
  device:DeviceFbs;
}

table LargeFormatTakeUpReelFbs
{
  device:DeviceFbs;
}

table FinisherFbs
{
  finisher:FinisherDeviceType;
  mediaDestinationId: dune.imaging.types.MediaDestinationId;
  // TODO fill out the finisher information
}

table FinisherCombinationFbs
{
  finishers:[FinisherFbs]; // TODO use the union type
}


table OutputFbs
{
  type:OutputType;
  output:OutputBinFbs; // TODO use the union type
  hasFinishers:dune.framework.core.fbs.APIResult;
  finishers:[FinisherFbs];
  hasValidFinisherCombinations:dune.framework.core.fbs.APIResult;
  validFinisherCombinations:[FinisherCombinationFbs];
}


table DuplexerFbs
{
  device:DeviceFbs;
}

table FlipperFbs
{
  device:DeviceFbs;
}

table PrintZoneFbs
{
  device:DeviceFbs;
  hasPrintZoneSnapshot:dune.framework.core.fbs.APIResult;
  printZoneSnapShot:PrintZoneSnapshotFbs;
}

table HeaterFbs
{
  device:DeviceFbs;
  hasHeaterSnapshot:dune.framework.core.fbs.APIResult;
  heaterSnapShot:HeaterSnapshotFbs;
}

table CuringFbs
{
  device:DeviceFbs;
  hasCuringSnapshot:dune.framework.core.fbs.APIResult;
  curingSnapShot:CuringSnapshotFbs;
}

table MediaPathFbs
{
  mediaPath:MediaPathDeviceType;
}
